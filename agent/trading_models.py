# Crypto_Trading_Bot/agent/trading_models.py

from enum import Enum
from typing import Optional, List, Dict, Any
import uuid
from pydantic import BaseModel, Field
from datetime import datetime

class OrderAction(str, Enum):
    """
    Defines the possible actions for a trading order.
    """
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD" # Represents a decision to not trade
    SHORT = "SHORT" # If short selling is considered
    COVER = "COVER" # To cover a short position

class OrderType(str, Enum):
    """
    Defines the type of order to be placed.
    """
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP_LOSS = "STOP_LOSS"
    TAKE_PROFIT = "TAKE_PROFIT"

class TradingSignal(BaseModel):
    """
    Represents a trading signal generated by a strategy.
    """
    symbol: str = Field(..., description="Trading symbol, e.g., 'BTC/USDT'")
    action: OrderAction = Field(..., description="The trading action to take (BUY, SELL, HOLD)")
    confidence: Optional[float] = Field(None, ge=0, le=1, description="Confidence level of the signal (0.0 to 1.0)")
    price: Optional[float] = Field(None, description="Target price for limit orders, or execution price for market orders if known post-facto")
    quantity_percentage: Optional[float] = Field(None, ge=0, le=1, description="Percentage of available capital to use for this trade")
    quantity_absolute: Optional[float] = Field(None, description="Absolute quantity of the asset to trade")
    stop_loss_price: Optional[float] = Field(None, description="Price at which to trigger a stop-loss order")
    take_profit_price: Optional[float] = Field(None, description="Price at which to trigger a take-profit order")
    signal_time: datetime = Field(default_factory=datetime.utcnow, description="Timestamp when the signal was generated")
    strategy_name: Optional[str] = Field(None, description="Name of the strategy that generated this signal")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Any additional metadata related to the signal")

    class Config:
        use_enum_values = True # Ensures enum values are used in serialization

# Add/Update OrderRequest if not already fully defined in base_exchange_adapter.py
class OrderRequest(BaseModel):
    """
    Represents a request to place an order.
    This will be passed to the exchange adapter.
    """
    request_id: str = Field(default_factory=lambda: f"req_{datetime.utcnow().timestamp()}_{uuid.uuid4().hex[:8]}", description="Unique request ID for tracking")
    symbol: str = Field(..., description="Trading symbol, e.g., 'BTC/USDT'")
    action: OrderAction = Field(..., description="BUY or SELL")
    order_type: OrderType = Field(..., description="MARKET, LIMIT, etc.")
    quantity: float = Field(..., gt=0, description="Amount of base currency to buy/sell (positive value)")
    price: Optional[float] = Field(None, description="Required for LIMIT orders; target price")
    client_order_id: Optional[str] = Field(None, description="Custom order ID for the exchange to prevent duplicates")
    strategy_name: Optional[str] = Field(None, description="Name of the strategy that originated this order request")
    # Add time_in_force, stop_loss, take_profit parameters as needed for more advanced orders
    # time_in_force: Optional[str] = Field(None, description="e.g., GTC, IOC, FOK")

    class Config:
        use_enum_values = True # Ensures enum values are used in serialization

class ExecutedOrder(BaseModel):
    """
    Represents an order that has been executed by the exchange.
    """
    order_id: str
    symbol: str
    action: OrderAction
    order_type: OrderType
    price: float # Actual execution price
    quantity: float # Actual executed quantity
    timestamp: datetime
    fee: Optional[float] = None
    fee_currency: Optional[str] = None
    status: str # e.g., 'FILLED', 'PARTIALLY_FILLED'

class AgentPortfolio(BaseModel):
    """
    Represents the agent's current portfolio holdings.
    """
    cash_balance: Dict[str, float] = Field(default_factory=dict, description="Cash balances in different currencies, e.g., {'USDT': 1000.0}")
    asset_holdings: Dict[str, float] = Field(default_factory=dict, description="Holdings of different crypto assets, e.g., {'BTC': 0.5}")
    total_value_usd: Optional[float] = Field(None, description="Estimated total portfolio value in USD")
    last_updated: datetime = Field(default_factory=datetime.utcnow)

    def update_cash(self, currency: str, amount_change: float):
        self.cash_balance[currency] = self.cash_balance.get(currency, 0.0) + amount_change
        self.last_updated = datetime.utcnow()

    def update_asset(self, asset: str, amount_change: float):
        self.asset_holdings[asset] = self.asset_holdings.get(asset, 0.0) + amount_change
        if self.asset_holdings[asset] < 1e-9: # Clean up negligible amounts
            del self.asset_holdings[asset]
        self.last_updated = datetime.utcnow()
    
    def calculate_total_value(self, market_prices: Dict[str, float]) -> float:
        """
        Calculate the total value of the portfolio in USD.
        This requires current market prices for all assets.
        """
        total_value = sum(self.cash_balance.get(currency, 0.0) for currency in self.cash_balance)
        for asset, amount in self.asset_holdings.items():
            total_value += amount * market_prices.get(asset, 0.0)
        self.total_value_usd = total_value
        return total_value
    
